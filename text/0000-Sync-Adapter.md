- Дата создания: 2018-02-05
- RFC PR:
- RFC Issue:
- Flexberry Issue:

# Универсальный интеграционный адаптер

## Краткое описание

> Необходимо разработать универсальный адаптер для решения задачи интеграции данных корпоративных приложений.

## Обоснование

> Часто на прикладных проектах возникает проблема интеграции данных между несколькими приложениями и разработчики, задействованные на проекте, с помощью различных технологий и архитектуры, создают свои решения, нацеленные на работу с конкретными приложениями. Отсюда вытекает проблема, что при возникновении задачи интеграции, зачастую необходимо начинать разработку решения с нуля, из-за невозможности переиспользования или отсутствия других решений. В результате разработки данного проектного решения планируется получить универсальный адаптер, который позволит разработчикам обеспечить интеграцию данных между приложениями с использованием общей технологии и архитектуры.

## Детальное проектирование

> Адаптер должен решать две первичные задачи
> * обеспечить возможность обмена данными между приложениями по средствам запросов и ответов
> * обеспечить непрерывную синхронизацию данных между приложениями

> Адаптер должен обладать следующими возможностями:
> 1. формировать запрос на получение данных из других источников
> 2. получать набор данных из другого источника и обрабатывать их
> 3. предоставлять данные по запросу
> 4. отправлять измененные за период данные в другой источник

> Основная идея - рядом с прикладным приложением разворачивается несколько сервисов синхронизации, которые в совокупности обеспечивают необходимую функциональность, при минимальном изменение внутри прикладного проекта-источника. В приложение-источник добавляется сборка с наблюдателями, которые собирают данные об изменениях объектов внутри прикладной системы. По запросу или временному регламенту собранные данные преобразуются и передаются приложению-приёмнику.
> За основу реализации синхронизации данных предлагается взять уже разработанный ранее проект Synchronizer, который позволяет реализовать сбор изменений объектов приложения-источника за счет реализованного механзима наблюдателя - Observer и механизма преобразование объектов одной системы в другую - Mapper.


### Описание решения на прикладном примере взаимодействия с сервисной шиной предприятия(ESB):

#### Описание сервисов синхронизации

**Схема решения**
![Схема решения](/Images/SyncAdapter/Sync-Adapter-Tech.png)

> Описание структуры базы данных синхронизации Sync DB:
> conformity - соответствие первичных ключей, применяется секционирование по колонкам source и type, заполняется когда обрабатываются входящие синхронизационные сообщения
> ics_syncentity - факты-изменения, заполняется когда происходит какое-либо изменение отслеживаемых прикладных данных
> ics_syncsetting - настройки наблюдателей и мапперов
> ics_syncsubsettings - дополнительные настройки маппинга мастеров
> ics_syncsystem - настройки сборок объектов, учавствующих в синхронизации
> ics_synctype - настройки типов объектов, учавствующих в синхронизации
> objecttype - настройки типов объектов, для которых будет вестись таблица соответствия первичных ключей
> source - названия источников входящих сообщений, заполняется при обработке синхронизационных сообщений
> synclogitem - журнал синхронизации, здесь хранятся входящие и исходящие сообщения

> Сервисы синхронизации делятся на следующие:
> 1. ASP.NET веб-служба SyncAdapter - преобразование объектов из одной системы в другую, регистрацию изменений и формирование из них пакетов синхронизации, а так же формирование и приём сообщений различных типов.
> В службу входят:
> * API - Web API содержит методы управляющие поведением адаптера.
> * Change Package Collector - модуль упаковщика фактов-изменений SyncEntity в сообщения для передачи в систему-приёмник.
> * MessageCreator - модуль формирования различных типов сообщений.
> * BusListener - модуль для получения входящих сообщений из шины, которые сохраняются в журнал синхронизации. 
> 2. Консольное приложение BusSender - отвечает за отправку готовых сообщений в шину с заданным периодом.
> 3. Консольное приложение MessageHandler - отвечает за обработку полученных сообщений с заданным периодом.

> Objects - сборка объектов синхронизатора, поставляется в виде nuget IIS.Synchronization.Objects, используется всеми сервисами.
> Utils - сборка утилит синхронизатора. Содержит различные полезные классы и методы,. Поставляется в виде nuget IIS.Synchronization.Utils, используется всеми сервисами.
> Synchronizer - сборка с общими механизмом маппинга и обсерверов, а так же сервисами для работы с их настройками. Поставляется в виде nuget IIS.Synchronizer.  

#### Описание работы модулей адаптера
**Изменение в прикладном приложении-источнике App**
> В приложение-источник App включается сборка в которой создаются наблюдатели (реализация ISyncObserver) за синхронизируемыми объектами. ISyncObserver – паттерн «наблюдатель», обеспечивает реакцию на изменение объекта синхронизации. Внутри наблюдателя может содержится логика по принятию решения о синхронизации объекта (Например, не хотим, чтобы при изменении некоторых отдельных полей объект синхронизировался - делается за счет создания специализируемого представления свойств объекта).

> Для работы наблюдателя, приложение должно вести аудит изменения своих объектов и использовать специализированный сервис аудита SyncAuditService, который поставляется в пакете IIS.Synchronizer. После фиксации аудита изменений вызывается соответствующий Observer изменённого объекта, в результате работы которого записывает факт об изменении объекта - SyncEntity в таблицу БД ics_syncentity.

**ASP.NET веб-служба SyncAdapter**
> На сервере приложения разворачивается веб-служба адаптер SyncAdapter. К SyncAdapter подключаются сборки объектов приложения-источника App Object и приложений-приёмников, в данном случаи - XML Object и создаются соответствующие сборкам объектов наборы мапперов.

> IIS.Synchronizer позволяет реализовать наборы преобразований объектов из одной системы в другую – мапперы (Реализация ISyncMapper) ISyncMapper – схож с паттерном «адаптер», обеспечивает преобразование объекта системы App в XML-объект для шины. Для изменения мастеров используются сабмапперы, настройки их использования прописываются отдельно. Детейлам соответствуют отдельные мапперы, где агрегатор выступает в роли мастера. Для преобразования из одного объекта в два используются два разных маппера с одним объектом-источником и разными объектами-приёмниками.

> Управление веб-службой SyncAdapter осуществляется за счет реализации средств Web API, гибкость которых позволяет управлять различными механизмами обмена данных. В базовой реализации, Web API предоставляет метод для возможности синхронизации всех сущностей за заданный период (все накопившиеся изменения отправить на синхронизацию). SyncAdapter имеет прямое подключение к БД источника для обработки запросов данных и записи изменений, полученных от других приложений.

> Для обмена сообщениями с шиной внутри адаптера используется xml-представление передаваемых и принимаемых данных, в виде объектной модели данных - XML Object и объектной модели сообщений XML Message Obj. Используя DataContract сериализатор объектные модели превращаются в xml строку и записываются в тело сообщения для шины.
> Для XML Message Obj определены следующие интерфейсы:
> * ICommonMessage - общий интерфейс для всех типов передаваемых сообщений
> * IDataChangeMessageRequest - интерфейс содержит определение для сообщения-запроса изменений
> * IDataChangeMessageResponse - интерфейс содержит определение для сообщения-ответа с изменениями
> Так же для сообщений определены следующие атрибуты:
> * PackageSize - атрибут для указания размера пакета сообщения
> * SendChangedField - атрибут, который указывает нужно ли в сообщение дописывать изменившиеся поля

> Для XML Object определены следующие интерфейсы:
> * IChangedItem - интерфейс содержит определение для передаваемого в сообщении изменения объекта
> * IType - интерфейс содержит определение типа, для запроса изменений по этому типу объектов
> Так же для объектов определены следующие атрибуты:
> * AliasType - атрибут для указания псевдонима типа(Пример: В сообщении-запросе тип может быть указан как "1403", у нас 1403 = Classifier)
> * ForceGetFullChangesType - флаг принудительного полного отката изменений объекта
> * XMLDataFieldType - атрибут для указания, что поле в классе является ссылкой на XML-класс данных. Type указывает на соответствующий тип объектов-источников.

**Change Package Collector**
> При поступлении внешнего запроса (пользователь в приложении-приёмнике нажал кнопку подтянуть справочники или произошёл вызов API-метода) в упаковщик передаются тип сообщения об изменении которое хотим сформировать(IDataChangeMessageResponse) и соответствующие ему объекты (IChangedItem) и далее работа упаковщика происходит по следующиму алгоритму:
> 1.    Вычисление времени с которого брать изменения. Период времени, в который нужно собрать изменения, может быть задан в параметрах упаковщика. Если период времени не задан или дата, с которой планировалось отправить изменения, меньше, чем дата отправки последнего sync-сообщение типа IDataChangeMessageResponse, то время с которого собирать изменения будет переопределено временем ChangesTo последнего сообщения типа IDataChangeMessageResponse. 
> 2.	Вычитываем все факты-изменения SyncEntity за установленный период времени. Количество вычитанных за раз фактов-изменения определяется размерностью пакета PackageSize для сообщения.
> 3.    Перебираем вычитанные факты-изменения. Порядок SyncEntity соответствует порядку в котором были записаны изменения в аудит.
> 4.	По факту-изменению создается изменённый объект. Изменённый объект, с помощью записей аудита, восстанавливается к состоянию на дату изменения.
> 5.    В механизме восстановления учавствуют лишь те поля, мастера и детейлы, которые определены в представление для маппинга. Восстановление объекта может происходит дву путями, регулируется настройкой в конфиге OnlySelfRollbackFromAudit:
>       * В один проход, при этом на дату изменения будут возвращены только все собственные поля объекта, включая первичные ключи мастеров и детейлов
> 	    * Рекурсивные вызовы, при этом на дату изменения будут возвращены все собственные поля объекта, включая ссылки на мастеров и детейлов, а так же их поля и ссылки>       
> 6.    Восстановленный объект преобразуется, используя соответствующий маппер, в объект для системы-приёмника, в нашем случаи объект из XML Object.
> 7.    Если для типа сообщения установлен атрибут SendChangedField, то в сообщение добавится список изменных полей. 
> 8.	Преобразованный объект добавляется в сообщение типа IDataChangeMessageResponse. Как только обработаются все вычитанные объекты, порция изменений считается обработанной, сформированное сообщение сохраняется, как SyncLogItem готовый к отправке.

**Схема сообщений**
![Схема сообщений](/Images/SyncAdapter/Sync-Adapter-MessageStruct.png)

**MessageCreator**
> MessageCreator - реализует паттерн Фабричный метод, для создания исходящих ICommonMessage XML-сообщений различного типа. Основной интерфейс IServiceBusMessageCreator. По-умолчанию содержит реализацию DataChangesCreator для создания сообщений типа IDataChangeMessageRespons. 

**BusListener**
> При получении сообщения из ESB создаётся запись SyncLogItem со статусом Prepared, в DataSet записывается полученное сообщение, на этом обработчик сообщения шины заканчивает работу.

**BusSender** 
> По расписанию запускается приложение BusSender, которое ищет в таблице SyncLogItem сообщения, готовые к отправке (Direction = Out и статус Prepared), создает сообщение для шины и отправляет их. 

> Если шина приняла сообщение, то статус SyncLogItem меняется на Success или на RespWaiting, если сообщение подразумевает получение ответа. В конце своей обработки BusSender проверяет были ли получены ответы на сообщения со статусом RespWaiting, если ответ получен то статус отправленного сообщения меняется на Success, иначе, если был превышен период ожидания ответа, администратору отправляется оповещение.

> Если отправка была неуспешной, то в лог производится запись с ошибкой отправки. Если сообщение не может отправиться в течение настраиваемого времени, то высылается оповещение и статус сообщения меняется на Invalid. Отправка не будет работать пока в очереди первое сообщение Invalid.

**MessageHandler**
> По расписанию запускается MessageHandler, который получает все входящие (Direction = In) SyncLogItem со статусом Prepared и обрабатывает полученное сообщение. После успешной обработки сообщения статус SyncLogItem переводится в Success. Если обработка прошла неуспешно, тогда сообщению присваивается статус Invalid и обработка останавливается (обработка будет пропускаться пока в очереди первое сообщение Invalid). Производится запись в лог с ошибкой обработки и отправка оповещения.

> Во время обработки записи синхронизации объектов при создания нового объекта может возникнуть коллизия ключей. Для решения это проблемы предлагается использовать специальную таблицу соответствия ключей – KeyMap (источник, ключ источника, тип, ключ приёмника)


## Документирование и обучение

> 1. Необходимо будет создать статью по предоставляемым возможностям и использованию этого решения в прикладных проектах.
> 2. В описание Аудита указать возможность применения новых методов. 
> 3. В описании шины добавить ссылку на это решение.

## Недостатки

> Один из возможных недостатков - предложенный шаблон службы-адаптера не будет обладать достаточно гибкой функциональностью, что не позволит решить ряд задач возникающих при интеграции приложений.

## Альтернативы

> Реализация подобных адаптеров за частую является узкоспециализированной для конкретного проектного решения, что не позволяет их использовать в других решениях.

## Нерешенные вопросы

> Проблемы:
> * Пост метод вызывающийся после фиксации изменений аудита. В параметр этому методу должен быть передан изменнённый объект, со статусом произощедшего изменения.
> * Получение состояния объекта на дату, используя аудит-изменения.
> * Механизм Change Package Collector. Возможность отправки разных данных синхронизации, разным приложениям-приемникам.
> * Части которые нужно вынести в общее решение.
> * Механизм разрешения соответствия первичных ключей между различными приложениями.
> * Синхронизация одного и того же объекта сразу несколькими системами-источниками.
